from __future__ import print_function

from collections import OrderedDict
from ctypes import (
    CDLL, sizeof, cast, byref, memset, c_char_p, c_uint, POINTER
)
from datetime import datetime

from . import arh
from .exceptions import ARSError


class ARS(object):
    """The ARS object implements a simple CRUD interface for Remedy ARS
    servers.  It is passed server details and credentials and acts as the main
    object which talks to Remedy ARS.

    The ARS object also provides a caching mechanism for schema lists and
    field mappings.

    :param str server: the Remedy ARS server to connect to
    :param str user: the username to authenticate with
    :param str password: the password to authenticate with
    :param int port: the port number of the server
    :param int rpc_program_number: the RPC program number of the server
    :raises: ARSError
    """

    def __init__(self, server, user, password, port=0, rpc_program_number=0):
        #: The Remedy ARS C API shared object file which is used to interact
        #: with the Remedy server
        self.arlib = CDLL('libar_lx64.so')

        #: The standard C library used to run several lower-lever C functions
        self.clib = CDLL('libc.so.6')

        #: The control record for each operation containing details about the
        #: user and session performing each operation
        self.control = arh.ARControlStruct()

        #: A list of warnings or errors generated from each call to Remedy ARS
        self.status = arh.ARStatusList()

        #: A list of tuples containing errors that occurred on the last call
        self.errors = []

        #: A cache containing all schemas
        self.schema_cache = None

        #: A cache containing field id to name mappings for schemas
        self.field_id_to_name_cache = {}

        #: A cache containing field name to id mappings for schemas
        self.field_name_to_id_cache = {}

        #: A cache containing field id to type mappings for schemas
        self.field_id_to_type_cache = {}

        #: A cache containing enum id to name mappings for a particular field
        self.enum_id_to_name_cache = {}

        #: A cache containing enum name to id mappings for a particular field
        self.enum_name_to_id_cache = {}

        # Initialise control to 0 for safety
        memset(byref(self.control), 0, sizeof(arh.ARControlStruct))

        # Load the ARControlStruct with server details and user credentials
        self.control.server = server
        self.control.user = user
        self.control.password = password

        # Note on FreeAR functions:
        #
        # FreeAR functions are used to clear the contents of memory for
        # particular struct types.  These functions are used when a Remedy ARS
        # operation fills a struct as a return value.
        #
        # The second argument in the FreeAR functions is a boolean
        # known as freeStruct which specifies whether the memory should be
        # deallocated along with the contents.

        # Performs server initalisation
        if (
            self.arlib.ARInitialization(
                # ARControlStruct *control: the control record
                byref(self.control),

                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Enable to perform initialisation against server '
                '{}'.format(server)
            )

        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        # Set the server port and/or RPC program number (if specified)
        if port or rpc_program_number:
            if (
                self.arlib.ARSetServerPort(
                    # ARControlStruct *control: the control record
                    byref(self.control),
                    # ARNameType server: the server to update with the port
                    self.control.server,
                    # int port: the port number
                    port,
                    # int rpcProgramNum: the RPC program of the server
                    rpc_program_number,

                    # (return) ARStatusList *status: notes, warnings or errors
                    # generated by the operation
                    byref(self.status)
                ) >= arh.AR_RETURN_ERROR
            ):
                self._update_errors()
                self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
                raise ARSError(
                    'Unable to set the port to {} and RPC program number to '
                    '{} for server {}'.format(port, rpc_program_number, server)
                )

            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

    def terminate(self):
        """Perform a cleanup and disconnect the session

        :raises: ARSError
        """

        if (
            self.arlib.ARTermination(
                # ARControlStruct *control: the control record
                byref(self.control),

                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError('Unable to terminate the server connection')

        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

    def schemas(self):
        """Retrieves a list of all available schemas on the specified Remedy
        ARS server

        :return: a list of schema names
        :raises: ARSError
        """

        # Use the cache if possible
        if self.schema_cache is not None:
            return self.schema_cache

        schema_list = arh.ARNameList()

        if (
            self.arlib.ARGetListSchema(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARTimestamp changedSince: retrieves forms with a chosen
                # modification timestamp
                0,
                # unsigned int schemaType: get all schemas
                arh.AR_LIST_SCHEMA_ALL,
                # ARNameType name: specify which form this depends on (ignored
                # with our schemaType)
                None,
                # ARInternalIdList *fieldIdList: filter the schemas by a given
                # set of fields
                None,
                # ARPropList *objPropList: search for specify object properties
                None,

                # (return) ARNameList *nameList: the list of schemas
                byref(schema_list),
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARNameList(byref(schema_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError('Unable to obtain a list of schemas')

        # Save the schema list into the cache
        self.schema_cache = [
            schema_list.nameList[i].value for i in range(schema_list.numItems)
        ]

        self.arlib.FreeARNameList(byref(schema_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        return self.schema_cache

    def fields(self, schema):
        """Returns a list of field names provided by a selected schema

        :param str schema: the schema name to retrieve field names for
        :raises: ARSError
        """

        self.update_fields(schema)
        return self.field_name_to_id_cache[schema].keys()

    def get(self, schema, entry_id, fields):
        """Retrieves a particular entry in the requested schema using the
        given entry id.

        :param str schema: the schema name to retrieve the entry for
        :param str entry_id: the entry id of the entry that you wish to retrieve
        :param fields: a list of field names to retrieve from the schema
        :type fields: list of strings
        :return: a dict containing the field names and values requested for
                 the respective entry id
        :raises: ARSError
        """

        # Ensure we have all field and enum details for the schema
        self.update_fields(schema)

        # Validate that all fields exist.  Note that this is performed here
        # so that we aren't in the middle of allocating memory to the
        # AREntryListFieldList struct when we realise a field is invalid.
        for field in fields:
            if field not in self.field_name_to_id_cache[schema]:
                raise ARSError(
                    'A field with name {} does not exist in schema '
                    '{}'.format(field, schema)
                )

        entry_id_list = arh.AREntryIdList()
        entry_id_list.numItems = 1
        entry_id_list.entryIdList = cast(
            self.clib.malloc(
                entry_id_list.numItems * sizeof(arh.AREntryIdType)
            ), POINTER(arh.AREntryIdType)
        )
        entry_id_list.entryIdList[0].value = entry_id

        internal_id_list = arh.ARInternalIdList()
        internal_id_list.numItems = len(fields)
        internal_id_list.internalIdList = cast(
            self.clib.malloc(
                internal_id_list.numItems * sizeof(arh.ARInternalId)
            ), POINTER(arh.ARInternalId)
        )

        for i, field in enumerate(fields):
            internal_id_list.internalIdList[i] = (
                self.field_name_to_id_cache[schema][field]
            )

        field_value_list = arh.ARFieldValueList()

        if (
            self.arlib.ARGetEntry(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the schema to retrieve the entry for
                schema,
                # AREntryIdList *entryId: the entry id to retrieve
                byref(entry_id_list),
                # ARInternalIdList *idList: the field ids to retrieve
                byref(internal_id_list),

                # (return) ARFieldValueList *fieldList: a list of key/value
                # pairs that provide the data for the retrieved entry.
                byref(field_value_list),
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
            self.arlib.FreeARInternalIdList(byref(internal_id_list), arh.FALSE)
            self.arlib.FreeARFieldValueList(byref(field_value_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to retrieve the entry with id {} from schema '
                '{}'.format(entry_id, schema)
            )

        # Create an empty dict for the values
        entry_values = {}

        for i in range(field_value_list.numItems):
            field_id = field_value_list.fieldValueList[i].fieldId
            field_name = self.field_id_to_name_cache[schema][field_id]
            value_struct = field_value_list.fieldValueList[i].value
            try:
                entry_values[field_name] = self._extract_field(
                    schema, field_id, value_struct
                )
            except ARSError:
                self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
                self.arlib.FreeARInternalIdList(
                    byref(internal_id_list), arh.FALSE
                )
                self.arlib.FreeARFieldValueList(
                    byref(field_value_list), arh.FALSE
                )
                self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
                raise

        self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
        self.arlib.FreeARInternalIdList(byref(internal_id_list), arh.FALSE)
        self.arlib.FreeARFieldValueList(byref(field_value_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        return entry_values

    def query(
        self, schema, qualifier, fields, offset=arh.AR_START_WITH_FIRST_ENTRY,
        limit=arh.AR_NO_MAX_LIST_RETRIEVE
    ):
        """Runs a specified qualification string against a chosen schema and
        returns the all related records with the fields specified by the
        caller.

        :param str schema: the schema name to run the query against
        :param str qualifier: the query determining which records to retrieve
        :param fields: a list of field names to retrieve from the schema
        :type fields: list of strings
        :param int offset: the index of the first record to retrieve
        :param int limit: limit the number of returned results to a given
                          number
        :return: a list of tuples containing the entries matching the criteria
                 specified whereby each tuple contains the entry id and
                 entry values
        :raises: ARSError
        """

        # Ensure we have all field and enum details for the schema
        self.update_fields(schema)

        # Validate that all fields exist.  Note that this is performed here
        # so that we aren't in the middle of allocating memory to the
        # AREntryListFieldList struct when we realise a field is invalid.
        for field in fields:
            if field not in self.field_name_to_id_cache[schema]:
                raise ARSError(
                    'A field with name {} does not exist in schema '
                    '{}'.format(field, schema)
                )

        qualifier_cstring = c_char_p(qualifier)
        qualifier_struct = arh.ARQualifierStruct()

        if (
            self.arlib.ARLoadARQualifierStruct(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the schema to build the qualifier for
                schema,
                # ARNameType displayTag: the name of the form view to use for
                # resolving field names
                None,
                # char *qualString: the qualification string (query) to search
                # with
                qualifier_cstring,

                # (return) ARQualifierStruct *qualifier: the newly built
                # ARQualifierStruct
                byref(qualifier_struct),
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARQualifierStruct(
                byref(qualifier_struct), arh.FALSE
            )
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to load the qualifier using the provided '
                'qualification string for schema {}'.format(schema)
            )

        # Note that we don't run FreeARQualifierStruct here as we need the
        # qualifier for the next call
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        field_list = arh.AREntryListFieldList()
        field_list.numItems = len(fields)
        field_list.fieldsList = cast(
            self.clib.malloc(
                field_list.numItems * sizeof(arh.AREntryListFieldStruct)
            ), POINTER(arh.AREntryListFieldStruct)
        )

        for i, field in enumerate(fields):
            field_list.fieldsList[i].fieldId = (
                self.field_name_to_id_cache[schema][field]
            )
            # From the C API Reference document (Chapter 3 / Entries)
            # For ARGetListEntryWithFields, set this value to a number greater
            # than 0.
            field_list.fieldsList[i].columnWidth = 1
            # From the C API Reference document (Chapter 3 / Entries)
            # For ARGetListEntryWithFields, set this value to one blank space.
            field_list.fieldsList[i].separator = b' '

        num_matches = c_uint()
        entry_list = arh.AREntryListFieldValueList()

        if (
            self.arlib.ARGetListEntryWithFields(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the schema to get entries for
                schema,
                # ARQualifierStruct *qualifier: a query specifying entries to
                # retrieve
                byref(qualifier_struct),
                # AREntryListFieldList *getListFields: a list of fields to
                # retrieve with each entry
                byref(field_list),
                # ARSortList *sortList: list of fields to sort results by
                # (NULL for default sort)
                None,
                # unsigned int firstRetrieve: the first record to retrieve
                offset,
                # unsigned int maxRetrieve: the maximum number of items to
                # retrieve
                limit,
                # ARBoolean useLocale: whether to search based on locale
                arh.FALSE,

                # (return) AREntryListFieldValueList *entryList: the entries
                # retrieved
                byref(entry_list),
                # (return) unsigned int numMatches: the number of entries
                # retrieved
                byref(num_matches),
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARQualifierStruct(
                byref(qualifier_struct), arh.FALSE
            )
            self.arlib.FreeAREntryListFieldList(byref(field_list), arh.FALSE)
            self.arlib.FreeAREntryListFieldValueList(
                byref(entry_list), arh.FALSE
            )
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to obtain a list of entries using the provided '
                'qualification string for schema {}'.format(schema)
            )

        entries = []

        for i in range(entry_list.numItems):
            # Entries containing more than one id are not supported
            # (ids are supposed to be unique aren't they?)
            if entry_list.entryList[i].entryId.numItems != 1:
                self.arlib.FreeARQualifierStruct(
                    byref(qualifier_struct), arh.FALSE
                )
                self.arlib.FreeAREntryListFieldList(
                    byref(field_list), arh.FALSE
                )
                self.arlib.FreeAREntryListFieldValueList(
                    byref(entry_list), arh.FALSE
                )
                self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
                raise ARSError(
                    'One or more entries contained multiple IDs that are not '
                    'supported by PyRemedy'
                )

            # Extract the entry id and create an empty dict for the values
            entry_id = entry_list.entryList[i].entryId.entryIdList[0].value
            entry_values = {}

            # Grab the values list for the entry
            field_value_list = entry_list.entryList[i].entryValues.contents

            for j in range(field_value_list.numItems):
                field_id = field_value_list.fieldValueList[j].fieldId
                field_name = self.field_id_to_name_cache[schema][field_id]
                value_struct = field_value_list.fieldValueList[j].value

                # Extract the appropriate piece of data depending on its type
                try:
                    entry_values[field_name] = self._extract_field(
                        schema, field_id, value_struct
                    )
                except ARSError:
                    self.arlib.FreeARQualifierStruct(
                        byref(qualifier_struct), arh.FALSE
                    )
                    self.arlib.FreeAREntryListFieldList(
                        byref(field_list), arh.FALSE
                    )
                    self.arlib.FreeAREntryListFieldValueList(
                        byref(entry_list), arh.FALSE
                    )
                    self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
                    raise

            entries.append((entry_id, entry_values))

        self.arlib.FreeARQualifierStruct(byref(qualifier_struct), arh.FALSE)
        self.arlib.FreeAREntryListFieldList(byref(field_list), arh.FALSE)
        self.arlib.FreeAREntryListFieldValueList(byref(entry_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        return entries

    def create(self, schema, entry_values):
        """Creates a new entry in a given schema using the provided entry
        values.

        :param str schema: the schema where the entry is to be created
        :param entry_values: a dict containing the field names and values
                             for the new entry
        :type entry_values: dict of string to values corresponding to the type
                            of the respective field
        :return: the entry id of the newly created entry
        :raises: ARSError
        """

        # Ensure we have all field and enum details for the schema
        self.update_fields(schema)

        # Validate that all fields exist.  Note that this is performed here
        # so that we aren't in the middle of allocating memory to the
        # ARFieldValueList struct when we realise a field is invalid.
        for field in entry_values.keys():
            if field not in self.field_name_to_id_cache[schema]:
                raise ARSError(
                    'A field with name {} does not exist in schema '
                    '{}'.format(field, schema)
                )

        # Prepare the fields that will be added to the new entry
        field_value_list = arh.ARFieldValueList()
        field_value_list.numItems = len(entry_values)
        field_value_list.fieldValueList = cast(
            self.clib.calloc(
                field_value_list.numItems, sizeof(arh.ARFieldValueStruct)
            ), POINTER(arh.ARFieldValueStruct)
        )

        # Create a variable to store the new entry id
        entry_id = arh.AREntryIdType()

        for i, (field_name, value) in enumerate(entry_values.items()):
            field_id = self.field_name_to_id_cache[schema][field_name]
            self._update_field(
                schema, field_id, value, field_value_list.fieldValueList[i]
            )

        if (
            self.arlib.ARCreateEntry(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the name of the schema to create the
                # entry in
                schema,
                # ARFieldValueList *fieldList: a list of key/value pairs which
                # identify the data for the new entry
                byref(field_value_list),

                # (return) AREntryIdType *entryId: the entry id of the newly
                # created entry
                byref(entry_id),
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARFieldValueList(
                byref(field_value_list), arh.FALSE
            )
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to create a new entry for schema {}'.format(schema)
            )

        self.arlib.FreeARFieldValueList(byref(field_value_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        # Return the newly created entry id to the caller
        return entry_id.value

    def update(self, schema, entry_id, entry_values):
        """Updates a chosen entry in a given schema using the provided
        entry values.

        :param str schema: the schema where the entry is located
        :param str entry_id: the entry id of the record to be updated
        :param entry_values: a dict containing the field names and values
                             to be updated
        :type entry_values: dict of string to values corresponding to the type
                            of the respective field
        :raises: ARSError
        """

        # Ensure we have all field and enum details for the schema
        self.update_fields(schema)

        # Validate that all fields exist.  Note that this is performed here
        # so that we aren't in the middle of allocating memory to the
        # ARFieldValueList struct when we realise a field is invalid.
        for field in entry_values.keys():
            if field not in self.field_name_to_id_cache[schema]:
                raise ARSError(
                    'A field with name {} does not exist in schema '
                    '{}'.format(field, schema)
                )

        # Prepare the entry id struct
        entry_id_list = arh.AREntryIdList()
        entry_id_list.numItems = 1
        entry_id_list.entryIdList = cast(
            self.clib.malloc(
                entry_id_list.numItems * sizeof(arh.AREntryIdType)
            ), POINTER(arh.AREntryIdType)
        )
        entry_id_list.entryIdList[0].value = entry_id

        # Prepare the fields that will be updated
        field_value_list = arh.ARFieldValueList()
        field_value_list.numItems = len(entry_values)
        field_value_list.fieldValueList = cast(
            self.clib.calloc(
                field_value_list.numItems, sizeof(arh.ARFieldValueStruct)
            ), POINTER(arh.ARFieldValueStruct)
        )

        for i, (field_name, value) in enumerate(entry_values.items()):
            field_id = self.field_name_to_id_cache[schema][field_name]
            self._update_field(
                schema, field_id, value, field_value_list.fieldValueList[i]
            )

        if (
            self.arlib.ARSetEntry(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the name of the schema containing the
                # entry to be updated
                schema,
                # AREntryIdList *entryId: the id of the entry to update
                byref(entry_id_list),
                # ARFieldValueList *fieldList: a list of key/value pairs to
                # update
                byref(field_value_list),
                # ARTimestamp getTime: the timestamp specifying when the entry
                # was last retrieved for validation against the modified date
                # (to bypass this comparison, pass 0)
                0,
                # unsigned int option: whether to update fields in a join
                # qualification (only applies to join forms)
                arh.AR_JOIN_SETOPTION_REF,

                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
            self.arlib.FreeARFieldValueList(byref(field_value_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to modify entry id {} for schema {}'.format(
                    entry_id, schema
                )
            )

        self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
        self.arlib.FreeARFieldValueList(byref(field_value_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

    def delete(self, schema, entry_id):
        """Deletes a particular entry in the requested schema using the
        given entry id.

        :param str schema: the schema name to delete the entry from
        :param str entry_id: the entry id of the entry that you wish to delete
        :raises: ARSError
        """

        entry_id_list = arh.AREntryIdList()
        entry_id_list.numItems = 1
        entry_id_list.entryIdList = cast(
            self.clib.malloc(
                entry_id_list.numItems * sizeof(arh.AREntryIdType)
            ), POINTER(arh.AREntryIdType)
        )
        entry_id_list.entryIdList[0].value = entry_id

        if (
            self.arlib.ARDeleteEntry(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the name of the schema containing the
                # entry to be deleted
                schema,
                # AREntryIdList *entryId: the entry to delete
                byref(entry_id_list),
                # unsigned int option: the policy used when deleting the entry
                arh.AR_JOIN_DELOPTION_NONE,

                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to delete entry id {} for schema {}'.format(
                    entry_id, schema
                )
            )

        self.arlib.FreeAREntryIdList(byref(entry_id_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

    def update_fields(self, schema):
        """Determines the field IDs for all data fields on a chosen schema and
        then retrieves the related field names and enum mappings.  This method
        assumes that all field names are unique.

        :param str schema: the schema name to retrieve field information for
        :raises: ARSError
        """

        # Use the cache if possible
        if (
            schema in self.field_id_to_name_cache and
            schema in self.field_name_to_id_cache and
            schema in self.field_id_to_type_cache and
            schema in self.enum_id_to_name_cache and
            schema in self.enum_name_to_id_cache
        ):
            return

        # Retrieve a list of IDs for a given form
        field_id_list = arh.ARInternalIdList()

        if (
            self.arlib.ARGetListField(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the schema to get field ids for
                schema,
                # unsigned long fieldType: bitmask indicating what field types
                # we want
                arh.AR_FIELD_TYPE_DATA,
                # ARTimestamp changedSince: retrieves fields with any
                # modification timestamp
                0,
                # ARPropList objPropList: object properties to search for
                None,

                # (return) ARInternalIdList *idList: the retrieved id list
                byref(field_id_list),
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARInternalIdList(byref(field_id_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to obtain field ids for schema {}'.format(schema)
            )

        # Note that we don't run FreeARInternalIdList here as we need the
        # field_id_list for the next call
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

        field_name_list = arh.ARNameList()
        field_exist_list = arh.ARBooleanList()
        field_limits_list = arh.ARFieldLimitList()

        if (
            self.arlib.ARGetMultipleFields(
                # ARControlStruct *control: the control record
                byref(self.control),
                # ARNameType schema: the scehma to get fields for
                schema,
                # ARInternalIdList *fieldId: the field ids to retrieve
                byref(field_id_list),

                # (return) ARBooleanList *existList: whether the fields exist
                # or not
                byref(field_exist_list),
                # (return) ARInternalIdList *fieldId2: the internal ids
                # retrieved
                None,
                # (return) ARNameList *fieldName: the field names
                byref(field_name_list),
                # (return) ARFieldMappingList *fieldMap: a mapping to the
                # underlying form which to retrieve fields
                None,
                # (return) ARUnsignedIntList *dataType: field data types
                None,
                # (return) ARUnsignedIntList *option: flags indicating whether
                # users must enter values in the form
                None,
                # (return) ARUnsignedIntList *createMode: flags that specify
                # the permission of fields
                None,
                # (return) ARUnsignedIntList *fieldOption: a list of bitmasks
                # indicating whether the field is to be audited or copied when
                # other fields are audited
                None,
                # (return) ARValueList *defaultVal: default field values
                None,
                # (return) ARPermissionListList *assignedGroupListList: groups
                # that have direct permission to fields
                None,
                # (return) ARPermissionListList *permissions: groups that can
                # access the fields
                None,
                # (return) ARFieldLimitList *limit: value limits fo fields
                byref(field_limits_list),
                # (return) ARDisplayInstanceListList *dInstanceList: display
                # properties
                None,
                # (return) ARTextStringList *helpText: help text
                None,
                # (return) ARTimestampList *timestamp: last modified timestamps
                None,
                # (return) ARAccessNameList *owner: the owner of fields
                None,
                # (return) ARAccessNameList *lastChanged: the user that made
                # the last change to the fields
                None,
                # (return) ARTextStringList *changeDiary: a list of change
                # entries
                None,
                # (return) ARPropListList *objPropListList: server properties
                # for fields
                None,
                # (return) ARStatusList *status: notes, warnings or errors
                # generated by the operation
                byref(self.status)
            ) >= arh.AR_RETURN_ERROR
        ):
            self._update_errors()
            self.arlib.FreeARInternalIdList(byref(field_id_list), arh.FALSE)
            self.arlib.FreeARBooleanList(byref(field_exist_list), arh.FALSE)
            self.arlib.FreeARNameList(byref(field_name_list), arh.FALSE)
            self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
            raise ARSError(
                'Unable to obtain field information for schema '
                '{}'.format(schema)
            )

        # Initialise the name and enum caches for this schema
        self.field_id_to_name_cache[schema] = OrderedDict()
        self.field_name_to_id_cache[schema] = OrderedDict()
        self.field_id_to_type_cache[schema] = OrderedDict()
        self.enum_id_to_name_cache[schema] = OrderedDict()
        self.enum_name_to_id_cache[schema] = OrderedDict()

        for i in range(field_id_list.numItems):
            # Save the field name to id mapping in the cache
            field_id = field_id_list.internalIdList[i]
            field_name = field_name_list.nameList[i].value
            data_type = field_limits_list.fieldLimitList[i].dataType

            # Save the field id to name mapping in the cache
            self.field_id_to_name_cache[schema][field_id] = field_name

            # Save the field name to id mapping in the cache
            self.field_name_to_id_cache[schema][field_name] = field_id

            # Save the field id to type mapping in the cache
            self.field_id_to_type_cache[schema][field_id] = data_type

            # Retrieve enum values if this field is an enum type
            if data_type == arh.AR_DATA_TYPE_ENUM:
                # Initialise the enum entries for this field
                self.enum_id_to_name_cache[schema][field_id] = {}
                self.enum_name_to_id_cache[schema][field_id] = {}

                field_enum_limits_list = (
                    field_limits_list.fieldLimitList[i].u.enumLimits
                )
                field_style = field_enum_limits_list.listStyle

                # Process regular enums mappings
                if field_style == arh.AR_ENUM_STYLE_REGULAR:
                    regular_list = field_enum_limits_list.u.regularList
                    for j in range(regular_list.numItems):
                        enum_id = j
                        enum_value = regular_list.nameList[j].value
                        self.enum_id_to_name_cache[schema][field_id][enum_id] = (
                            enum_value
                        )
                        self.enum_name_to_id_cache[schema][field_id][enum_value] = (
                            enum_id
                        )

                # Process custom enums mappings
                elif field_style == arh.AR_ENUM_STYLE_CUSTOM:
                    custom_list = field_enum_limits_list.u.customList
                    for j in range(custom_list.numItems):
                        enum_id = custom_list.enumItemList[j].itemNumber
                        enum_value = custom_list.enumItemList[j].itemName
                        self.enum_id_to_name_cache[schema][field_id][enum_id] = (
                            enum_value
                        )
                        self.enum_name_to_id_cache[schema][field_id][enum_value] = (
                            enum_id
                        )

                # Process query enums mappings
                else:
                    self.arlib.FreeARInternalIdList(
                        byref(field_id_list), arh.FALSE
                    )
                    self.arlib.FreeARBooleanList(
                        byref(field_exist_list), arh.FALSE
                    )
                    self.arlib.FreeARNameList(
                        byref(field_name_list), arh.FALSE
                    )
                    self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)
                    raise ARSError(
                        'The field id {} for schema {} is a query enum which '
                        'is not supported by PyRemedy'.format(field_id, schema)
                    )

        self.arlib.FreeARInternalIdList(byref(field_id_list), arh.FALSE)
        self.arlib.FreeARBooleanList(byref(field_exist_list), arh.FALSE)
        self.arlib.FreeARNameList(byref(field_name_list), arh.FALSE)
        self.arlib.FreeARStatusList(byref(self.status), arh.FALSE)

    def _extract_field(self, schema, field_id, value_struct):
        """Returns the appropriate value for the schema and field id requested
        given a particular value structure.

        :param str schema: the schema name related to the field you're extract
                           data for
        :param str field_id: the field id of the schema being retrieved
        :param ARValueStruct value_struct: the Remedy ARValueStruct containing
                                           the data
        :return: the value of the field requested
        :raises: ARSError
        """
        # Determine the data type of the value
        data_type = value_struct.dataType

        # Retrieve the field name from the cache
        field_name = self.field_id_to_name_cache[schema][field_id]

        # Based on the data type, retrieve and convert (if necessary) the
        # appropriate value and return it to the caller
        if data_type == arh.AR_DATA_TYPE_NULL:
            return None
        elif data_type == arh.AR_DATA_TYPE_INTEGER:
            return value_struct.u.intVal
        elif data_type == arh.AR_DATA_TYPE_REAL:
            return value_struct.u.realVal
        elif data_type == arh.AR_DATA_TYPE_CHAR:
            return str(value_struct.u.charVal)
        elif data_type == arh.AR_DATA_TYPE_ENUM:
            return (
                self.enum_id_to_name_cache[schema][field_id][value_struct.u.enumVal]
            )
        elif data_type == arh.AR_DATA_TYPE_TIME:
            return datetime.fromtimestamp(value_struct.u.timeVal)
        else:
            raise ARSError(
                'An unknown data type was encountered for field name '
                '{} on schema {}'.format(field_name, schema)
            )

    def _update_field(self, schema, field_id, value, field_value_struct):
        """Updates a provided ARFieldValueStruct item with the appropriate
        field information based on the type of value provided.

        :param str schema: the schema name related to the field you're updating
        :param str field_id: the field id of the schema being updated
        :param value: the value that is to be placed in the given field id
        :type value: a value corresponding to the type of the respective field
        :param ARFieldValueStruct field_value_struct: a ARFieldValueStruct to
                                                      update with the given
                                                      field id and value
        :raises: ARSError
        """

        # Determine the data type of the value
        data_type = self.field_id_to_type_cache[schema][field_id]

        # Retrieve the field name from the cache
        field_name = self.field_id_to_name_cache[schema][field_id]

        field_value_struct.fieldId = field_id
        field_value_struct.value.dataType = data_type
        if data_type == arh.AR_DATA_TYPE_NULL:
            pass
        elif data_type == arh.AR_DATA_TYPE_INTEGER:
            field_value_struct.value.u.intVal = value
        elif data_type == arh.AR_DATA_TYPE_REAL:
            field_value_struct.value.u.realVal = value
        elif data_type == arh.AR_DATA_TYPE_CHAR:
            # Note that we must allocate a new block of memory using
            # strdup or we end up with a nasty invalid pointer error
            field_value_struct.value.u.charVal = self.clib.strdup(value)
        elif data_type == arh.AR_DATA_TYPE_ENUM:
            enum_id = self.enum_name_to_id_cache[schema][field_id][value]
            field_value_struct.value.u.enumVal = enum_id
        elif data_type == arh.AR_DATA_TYPE_TIME:
            field_value_struct.value.u.timeVal = value.strftime('%s')
        else:
            raise ARSError(
                'An unknown data type was encountered for field name {} '
                'on schema {}'.format(field_name, schema)
            )

    def _update_errors(self):
        """Updates the errors attribute with any errors that occurred on the
        last operation based on the status struct.
        """

        # Clear previous errors
        self.errors = []

        # Go through each error present and add them to the errors list
        for i in range(self.status.numItems):
            message_number = self.status.statusList[i].messageNum
            message_text = str(self.status.statusList[i].messageText)
            appended_text = None

            if self.status.statusList[i].appendedText:
                appended_text = str(self.status.statusList[i].appendedText)

            self.errors.append((message_number, message_text, appended_text))
